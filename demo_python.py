# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rsEpVLW57c2no3tG4USU21tga4UjcGwg
"""

import numpy as np
from numpy.linalg import norm
from lrtv import LRTV


import scipy.io as sio
import matplotlib.pyplot as plt


inp=sio.loadmat("D:\\IS project\\segpy.mat")
inp=inp[list(inp.keys())[-1]]
inp=(inp-inp.min())/(inp.max()-inp.min())
#noisy_org=inp+0.1*np.random.randn(inp.shape[0],inp.shape[1],inp.shape[2])
#noisy = noisy_org[0:142,0:142,:]
noisy=inp[:100,162:,:300]

p,M,N=noisy.shape

win = [M,N]
channel_size = 20
# new_m = M - win_size
# new_n = N - win_size
# new_p = p - channel_size
tau = 0.0015
# lmbda = 15
overlap = 50
lmbda=20/np.sqrt(M*N)
r=35

stride = 10

denoised = np.zeros((p,M,N))

weights = np.zeros((p,M,N))
incremental_win = np.ones((p,win[M],win[N]))

for i in range(0, M-1, win[M]):
    for j in range(0, N-1, win[N]):
        for k in range(0, p-1, channel_size):
            try:
                print(k, i, j)
                noisy_patch = noisy[k:k+channel_size, i:i+win[M], j:j+win[N]]
                if k > 0:
                    print("first")
                    noisy_patch = noisy[k-stride:k+channel_size, i:i+win[M], j:j+win[N]]
                    denoised[k-stride:k+channel_size, i:i+win[M], j:j+win[N]] = LRTV(noisy_patch, tau, lmbda, r)
                    weights[i:i+win[M]-1, j:j+win[N], :] =  weights[i:i+win[M]-1, j:j+win[N], :] + incremental_win
                    output_image = LRTV(noisy_patch, tau, lmbda, r)
                    denoised[:k+channel_size, i:i+win[M], j:j+win[N]] = denoised[:k+channel_size, i:i+win[M], j:j+win[N]] + output_image
                else:
                    print("second")
                    denoised[:k+channel_size, i:i+win[M], j:j+win[N]] = LRTV(noisy_patch, tau, lmbda, r)
                    weights[i:i+win[M]-1, j:j+win[N], :] =  weights[i:i+win[M]-1, j:j+win[N], :] + incremental_win
                    output_image = LRTV(noisy_patch, tau, lmbda, r)
                    denoised[:k+channel_size, i:i+win[M], j:j+win[N]] = denoised[:k+channel_size, i:i+win[M], j:j+win[M]] + output_image
            except ValueError:
                            print(f"Skipping iteration with k = {k}, i = {i}, j = {j} due to ValueError")
                            continue
        

######

denoised_final = denoised/weights
np.save()

            
plt.imshow(inp[75,:,:],cmap='gray') # plt.imshow(inp[:,:,200],cmap='gray')
plt.imshow(noisy[75,:,:],cmap='gray') # plt.imshow(inp[:,:,200],cmap='gray')
plt.figure()
plt.show()
plt.imshow(denoised_final[99,:,:],cmap='gray')
plt.figure()
plt.show()


