# -*- coding: utf-8 -*-
"""LRTV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r0NM0mdaJi0n1S4Y6EyuyWLm_HOwCMU6
"""

import numpy as np
from numpy.linalg import norm

def gradient_op(I,*args):
  dx=I[1:,:]-I[:I.shape[0]-1,:]
  dy=I[:,1:]-I[:,:I.shape[1]-1]
  dx=np.vstack((dx,np.zeros((1,I.shape[1]))))
  dy=np.hstack((dy,np.zeros((I.shape[0],1))))

  if len(args)>1:
    dx=np.multiply(dx,args[0])
    dy=np.multiply(dy,args[1])

  return dx,dy

def div_op(dx,dy,*args):
  if(len(args)>1):
    dx=np.multiply(dx,np.conj(args[0]))
    dy=np.multiply(dy,np.conj(args[1]))

  I=np.vstack((dx[0,:],dx[1:dx.shape[0]-1,:]-dx[:dx.shape[0]-2,:],-dx[dx.shape[0]-2,:]))
  I=I+np.hstack((dy[:,0].reshape(-1,1),dy[:,1:dy.shape[1]-1]-dy[:,:dy.shape[1]-2],-dy[:,dy.shape[1]-2].reshape(-1,1)))

  return I

def TV_norm(u):
  dx,dy=gradient_op(u)
  temp=np.sqrt(np.power(np.abs(dx),2)+np.power(np.abs(dy),2))
  return np.sum(temp)

def prox_TV(b,lmbda,given_rel_obj=1e-4,verbose=1,max_iter=200):
  #initializations:
  r,s=gradient_op(np.zeros((b.shape[0],b.shape[1])))
  pold=r.copy();
  qold=s.copy();
  told=1
  prev_obj=0
  #Main iterations
  for iter in range(0,max_iter):
    #current sol
    sol=b-lmbda*div_op(r,s)
    #Obj fun value
    obj=0.5*norm(b-sol,'fro')**2+lmbda*TV_norm(sol)
    rel_obj = np.abs(obj-prev_obj)/obj
    prev_obj=obj
    #stopping criteria
    if (rel_obj<given_rel_obj):
      break
    #Udpate divergence vectors and project
    dx,dy=gradient_op(sol)
    r=r-1/(8*lmbda)*dx
    s=s-1/(8*lmbda)*dy
    weights=np.maximum(1,np.sqrt(np.power(np.abs(r),2)+np.power(np.abs(s),2)))
    p=r/weights
    q=s/weights
    #FISTA update
    t=0.5*(1+np.sqrt(4*told*told))
    r=p+(told-1)/t*(p-pold)
    pold=p
    s=q+(told-1)/t*(q-qold)
    qold=q
    told=t
  #print("ProxTV objective is:"+str(obj))
  return sol

def LRTV(oriData3_noise,tau,lmbda,r):
  p,M,N, = oriData3_noise.shape
  D=np.zeros((M*N,p))
  for i in range(0,p):
    bandp=oriData3_noise[:,:,i]
    D[:,i]=bandp.reshape(M*N,1,order="F")[:,0]
  d,p=D.shape
  d_norm=norm(D,'fro')
  tol = 1e-6
  tol1 = tol
  tol2 = tol1
  maxIter = 100
  rho = 1.5
  max_mu1 = 1e6
  mu1 = 1e-2
  mu2  = mu1
  mu3 = mu2
  sv =10
  #Initializing optimization variables
  L = np.random.rand(d,p)
  X = L.copy()
  E = np.zeros((d,p))
  Y1 = np.zeros((d,p))
  Y2 = np.zeros((d,p))
  iter=0
  while iter<maxIter:
    iter=iter+1
    temp=(mu1*X+mu2*(D-E)+(Y1+Y2))/(mu1+mu2)
    U,S,V=np.linalg.svd(temp,full_matrices=False)
    svp=min(np.where(S>(1/(mu1+mu2)))[0].size,r)
    if (svp<sv):
      sv=min(svp+1,p)
    else:
      sv=min(svp+np.round(0.05*p),p)
    svals=S[:svp]-(1/(mu1+mu2))
    L=np.dot(U[:,:svp]*svals,V[:svp,:])
    temp=L-Y1/mu1
    X=L
    for i in range(0,p):
      z=prox_TV(np.reshape(temp[:,i].reshape(-1,1),(M,N),order="F"),2*tau/mu1,max_iter=20)
      X[:,i]=z.reshape(z.size,1,order="F")[:,0]
    temp_E = D - L + Y2/mu2
    E_hat = np.maximum(temp_E - lmbda/mu2, 0)
    E = E_hat+np.minimum(temp_E + lmbda/mu2, 0)
    leq1 = X - L
    leq2 = D -L -E
    stopC1=np.max(np.abs(leq1))
    stopC2=norm(leq2,'fro')/d_norm
    print("iter:"+str(iter)+",stopALM="+str(stopC2)+",stopE="+str(stopC1))
    if (stopC1<tol and stopC2<tol2):
      break
    else:
      Y1=Y1+mu1*leq1
      Y2=Y2+mu2*leq2
      mu1 = min(max_mu1,mu1*rho);
      mu2 = min(max_mu1,mu2*rho);  

  output_image=np.reshape(L,(M,N,p),order="F")
  return output_image

import scipy.io as sio
import matplotlib.pyplot as plt

inp=sio.loadmat("simu_indian.mat")
inp=inp[list(inp.keys())[-1]]
inp=(inp-inp.min())/(inp.max()-inp.min())
noisy=inp+0.03*np.random.randn(inp.shape[0],inp.shape[1],inp.shape[2])
#noisy=noisy[:80,:80,:100]
plt.imshow(noisy[:,:,10],cmap='gray')

M,N,p=noisy.shape
lmbda=20/np.sqrt(M*N)
r=10
lrtv=LRTV(noisy,0.015,lmbda, r)

plt.imshow(lrtv[:,:,10],cmap='gray')